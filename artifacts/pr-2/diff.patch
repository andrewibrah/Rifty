diff --git a/App.tsx b/App.tsx
index 3be4cba..9723e9e 100644
--- a/App.tsx
+++ b/App.tsx
@@ -12,15 +12,19 @@ import {
   FlatList,
   Image,
   KeyboardAvoidingView,
+  Modal,
   PanResponder,
   type PanResponderGestureState,
   Platform,
   StatusBar,
   StyleSheet,
   Text,
+  TextInput,
   TouchableOpacity,
   View,
+  ScrollView,
 } from "react-native";
+import AsyncStorage from "@react-native-async-storage/async-storage";
 import { SafeAreaView, SafeAreaProvider } from "react-native-safe-area-context";
 import { GestureHandlerRootView } from "react-native-gesture-handler";
 import type { Session } from "@supabase/supabase-js";
@@ -34,9 +38,10 @@ import ScheduleCalendarModal from "./src/components/ScheduleCalendarModal";
 import OnboardingFlow from "./src/screens/onboarding/OnboardingFlow";
 import PersonalizationSettingsScreen from "./src/screens/settings/PersonalizationSettingsScreen";
 import Auth from "./src/components/Auth";
-import { useChatState } from "./src/hooks/useChatState";
+import { useChatState, type IntentReviewTicket } from "./src/hooks/useChatState";
 import { useMenuState } from "./src/hooks/useMenuState";
-import type { MessageGroup } from "./src/types/chat";
+import type { ChatMessage, MessageGroup } from "./src/types/chat";
+import type { MainHistoryRecord } from "./src/types/history";
 import { getColors, spacing, radii, typography, shadows } from "./src/theme";
 import { useTheme } from "./src/contexts/ThemeContext";
 import { supabase } from "./src/lib/supabase";
@@ -50,6 +55,14 @@ import type {
   PersonaTag,
 } from "./src/types/personalization";
 import { useEventLog } from "./src/hooks/useEventLog";
+import {
+  allIntentDefinitions,
+  getIntentById,
+  type AppIntent,
+} from "./src/constants/intents";
+import { MAIN_HISTORY_STORAGE_KEY } from "./src/constants/storage";
+import { logIntentAudit } from "./src/services/data";
+import { Memory } from "./src/agent/memory";
 
 const SPLASH_DURATION = 2500;
 const MIGRATION_FLAG =
@@ -90,6 +103,7 @@ const ChatScreen: React.FC<ChatScreenProps> = ({
     sendMessage,
     retryMessage,
     clearMessages,
+    updateMessageIntent,
   } = useChatState(menuState.refreshAllEntryCounts);
 
   const [content, setContent] = useState("");
@@ -99,6 +113,13 @@ const ChatScreen: React.FC<ChatScreenProps> = ({
   const [currentScreen, setCurrentScreen] = useState<
     "chat" | "settings" | "personalization"
   >("chat");
+  const [intentReviewQueue, setIntentReviewQueue] = useState<IntentReviewTicket[]>([]);
+  const [activeIntentReview, setActiveIntentReview] = useState<
+    IntentReviewTicket | null
+  >(null);
+  const [customIntentValue, setCustomIntentValue] = useState("");
+  const [isSubmittingIntentFeedback, setIsSubmittingIntentFeedback] =
+    useState(false);
 
   const splashOpacity = useRef(new Animated.Value(1)).current;
   const flameTranslate = useRef(new Animated.Value(0)).current;
@@ -153,10 +174,29 @@ const ChatScreen: React.FC<ChatScreenProps> = ({
     };
   }, [flameScale, flameTranslate, splashOpacity]);
 
+  useEffect(() => {
+    if (activeIntentReview) return;
+    const [nextReview, ...rest] = intentReviewQueue;
+    if (!nextReview) return;
+    setActiveIntentReview(nextReview);
+    setIntentReviewQueue(rest);
+    setCustomIntentValue("");
+  }, [activeIntentReview, intentReviewQueue]);
+
+  useEffect(() => {
+    Memory.warmup().catch((error) => {
+      console.warn('[memory] warmup failed', error);
+    });
+  }, []);
+
   const handleSend = async () => {
-    if (!content.trim()) return;
-    await sendMessage(content);
+    const trimmed = content.trim();
+    if (!trimmed) return;
+    const review = await sendMessage(trimmed);
     setContent("");
+    if (review) {
+      setIntentReviewQueue((prev) => [...prev, review]);
+    }
 
     requestAnimationFrame(() => {
       listRef.current?.scrollToEnd({ animated: true });
@@ -193,6 +233,32 @@ const ChatScreen: React.FC<ChatScreenProps> = ({
   const [isGestureActive, setIsGestureActive] = useState(false);
   const [gestureProgress, setGestureProgress] = useState(0);
 
+  const archiveConversation = useCallback(async () => {
+    if (messages.length === 0) {
+      return;
+    }
+
+    const snapshot: ChatMessage[] = JSON.parse(JSON.stringify(messages));
+
+    const record: MainHistoryRecord = {
+      id: `${Date.now()}`,
+      timestamp: new Date().toISOString(),
+      messages: snapshot,
+    };
+
+    try {
+      const raw = await AsyncStorage.getItem(MAIN_HISTORY_STORAGE_KEY);
+      const history: MainHistoryRecord[] = raw ? JSON.parse(raw) : [];
+      const next = [record, ...history].slice(0, 20);
+      await AsyncStorage.setItem(
+        MAIN_HISTORY_STORAGE_KEY,
+        JSON.stringify(next)
+      );
+    } catch (error) {
+      console.error("Failed to archive conversation", error);
+    }
+  }, [messages]);
+
   // Handle clear chat with confirmation
   const handleClearChat = useCallback(() => {
     Alert.alert(
@@ -206,11 +272,197 @@ const ChatScreen: React.FC<ChatScreenProps> = ({
         {
           text: "Clear",
           style: "destructive",
-          onPress: clearMessages,
+          onPress: () => {
+            archiveConversation().finally(() => clearMessages());
+          },
         },
       ]
     );
-  }, [clearMessages]);
+  }, [archiveConversation, clearMessages]);
+
+  const submitIntentFeedback = useCallback(
+    async (correctIntent: string, displayLabel?: string) => {
+      if (!activeIntentReview) return;
+      setIsSubmittingIntentFeedback(true);
+      try {
+        await logIntentAudit({
+          entryId: activeIntentReview.messageId,
+          prompt: activeIntentReview.content,
+          predictedIntent: activeIntentReview.intent.id,
+          correctIntent,
+        });
+
+        if (correctIntent !== "unknown") {
+          const isCustom = correctIntent.startsWith("custom:");
+          const baseDefinition = getIntentById(
+            (isCustom ? "unknown" : correctIntent) as AppIntent
+          );
+          const label = (displayLabel ?? (isCustom
+            ? correctIntent
+                .replace(/^custom:/, "")
+                .replace(/[-_]+/g, " ")
+                .trim() || "Custom Intent"
+            : baseDefinition.label)).trim();
+          const metaId = isCustom
+            ? ("unknown" as AppIntent)
+            : (correctIntent as AppIntent);
+          const confidence =
+            correctIntent === activeIntentReview.intent.id
+              ? activeIntentReview.intent.confidence
+              : 1;
+
+          const probabilities = {
+            ...activeIntentReview.intent.probabilities,
+            [label]:
+              correctIntent === activeIntentReview.intent.id
+                ? activeIntentReview.intent.probabilities[label] ?? confidence
+                : 1,
+          };
+
+          const meta = {
+            id: metaId,
+            rawLabel: label,
+            displayLabel: label,
+            confidence,
+            subsystem: baseDefinition.subsystem,
+            probabilities,
+          };
+
+          const resolvedType =
+            baseDefinition.entryType ?? activeIntentReview.entryType;
+
+          updateMessageIntent(activeIntentReview.messageId, meta, resolvedType);
+        }
+
+        setActiveIntentReview(null);
+        setCustomIntentValue("");
+      } catch (error) {
+        Alert.alert(
+          "Intent feedback failed",
+          error instanceof Error
+            ? error.message
+            : "Unable to record feedback right now."
+        );
+      } finally {
+        setIsSubmittingIntentFeedback(false);
+      }
+    },
+    [activeIntentReview, updateMessageIntent]
+  );
+
+  const handleSubmitCustomIntent = useCallback(() => {
+    const value = customIntentValue.trim();
+    if (!value) {
+      return;
+    }
+    const customId = `custom:${value
+      .toLowerCase()
+      .replace(/[^a-z0-9]+/g, "-")
+      .replace(/^-+|-+$/g, "")}`;
+    submitIntentFeedback(customId, value);
+  }, [customIntentValue, submitIntentFeedback]);
+
+  const handleSkipIntentReview = useCallback(() => {
+    submitIntentFeedback("unknown");
+  }, [submitIntentFeedback]);
+
+  const renderIntentReviewModal = () => {
+    if (!activeIntentReview) return null;
+
+    const predictedDefinition = getIntentById(
+      activeIntentReview.intent.id as AppIntent
+    );
+
+    return (
+      <Modal transparent animationType="fade" visible>
+        <View style={styles.intentModalBackdrop}>
+          <View style={styles.intentModalCard}>
+            <Text style={styles.intentModalTitle}>Confirm intent</Text>
+            <Text style={styles.intentModalMessage}>
+              {activeIntentReview.content}
+            </Text>
+            <View style={styles.intentPredictedBox}>
+              <Text style={styles.intentPredictedLabel}>Predicted</Text>
+              <Text style={styles.intentPredictedValue}>
+                {predictedDefinition.label}
+              </Text>
+              <Text style={styles.intentPredictedConfidence}>{`${Math.round(
+                activeIntentReview.intent.confidence * 100
+              )}% confidence`}</Text>
+              <TouchableOpacity
+                style={[
+                  styles.intentActionButton,
+                  styles.intentConfirmButton,
+                  isSubmittingIntentFeedback && styles.intentButtonDisabled,
+                ]}
+                onPress={() =>
+                  submitIntentFeedback(activeIntentReview.intent.id)
+                }
+                disabled={isSubmittingIntentFeedback}
+              >
+                <Text style={styles.intentActionButtonText}>Correct</Text>
+              </TouchableOpacity>
+            </View>
+            <Text style={styles.intentOptionsHeader}>Select intent</Text>
+            <ScrollView style={styles.intentOptionsList}>
+              {allIntentDefinitions
+                .filter((definition) => definition.id !== activeIntentReview.intent.id)
+                .map((definition) => (
+                  <TouchableOpacity
+                    key={definition.id}
+                    style={styles.intentOptionRow}
+                    onPress={() => submitIntentFeedback(definition.id)}
+                    disabled={isSubmittingIntentFeedback}
+                  >
+                    <View>
+                      <Text style={styles.intentOptionLabel}>
+                        {definition.label}
+                      </Text>
+                      <Text style={styles.intentOptionMeta}>
+                        {definition.subsystem.toUpperCase()}
+                      </Text>
+                    </View>
+                  </TouchableOpacity>
+                ))}
+            </ScrollView>
+            <View style={styles.intentCustomRow}>
+              <TextInput
+                style={styles.intentCustomInput}
+                value={customIntentValue}
+                onChangeText={setCustomIntentValue}
+                placeholder="Custom intent"
+                placeholderTextColor="rgba(255,255,255,0.5)"
+              />
+              <TouchableOpacity
+                style={[
+                  styles.intentActionButton,
+                  styles.intentSubmitButton,
+                  (isSubmittingIntentFeedback || !customIntentValue.trim()) &&
+                    styles.intentButtonDisabled,
+                ]}
+                onPress={handleSubmitCustomIntent}
+                disabled={
+                  isSubmittingIntentFeedback || !customIntentValue.trim()
+                }
+              >
+                <Text style={styles.intentActionButtonText}>Submit</Text>
+              </TouchableOpacity>
+            </View>
+            <TouchableOpacity
+              style={[
+                styles.intentSkipButton,
+                isSubmittingIntentFeedback && styles.intentButtonDisabled,
+              ]}
+              onPress={handleSkipIntentReview}
+              disabled={isSubmittingIntentFeedback}
+            >
+              <Text style={styles.intentSkipText}>Skip for now</Text>
+            </TouchableOpacity>
+          </View>
+        </View>
+      </Modal>
+    );
+  };
 
   const animateMainContent = useCallback(
     (toValue: number) => {
@@ -425,6 +677,8 @@ const ChatScreen: React.FC<ChatScreenProps> = ({
         onClose={handleCalendarClose}
       />
 
+      {renderIntentReviewModal()}
+
       {isSplashVisible && (
         <Animated.View
           style={[styles.splashContainer, { opacity: splashOpacity }]}
@@ -513,6 +767,128 @@ const createStyles = (colors: any) =>
       width: 120,
       height: 120,
     },
+    intentModalBackdrop: {
+      position: "absolute",
+      top: 0,
+      left: 0,
+      right: 0,
+      bottom: 0,
+      backgroundColor: "rgba(0,0,0,0.6)",
+      justifyContent: "center",
+      alignItems: "center",
+      padding: spacing.lg,
+    },
+    intentModalCard: {
+      width: "100%",
+      maxWidth: 420,
+      backgroundColor: colors.surfaceElevated,
+      borderRadius: radii.lg,
+      padding: spacing.lg,
+      borderWidth: 1,
+      borderColor: colors.border,
+    },
+    intentModalTitle: {
+      ...typography.title,
+      fontSize: 20,
+      color: colors.textPrimary,
+      marginBottom: spacing.sm,
+    },
+    intentModalMessage: {
+      ...typography.body,
+      color: colors.textSecondary,
+      marginBottom: spacing.md,
+    },
+    intentPredictedBox: {
+      padding: spacing.md,
+      backgroundColor: colors.surface,
+      borderRadius: radii.md,
+      borderWidth: 1,
+      borderColor: colors.border,
+      marginBottom: spacing.lg,
+    },
+    intentPredictedLabel: {
+      ...typography.caption,
+      color: colors.textSecondary,
+      marginBottom: spacing.xs,
+    },
+    intentPredictedValue: {
+      ...typography.title,
+      fontSize: 18,
+      color: colors.textPrimary,
+    },
+    intentPredictedConfidence: {
+      ...typography.caption,
+      color: colors.textSecondary,
+      marginTop: spacing.xs,
+    },
+    intentActionButton: {
+      marginTop: spacing.sm,
+      paddingVertical: spacing.sm,
+      paddingHorizontal: spacing.md,
+      borderRadius: radii.pill,
+      alignItems: "center",
+    },
+    intentButtonDisabled: {
+      opacity: 0.5,
+    },
+    intentConfirmButton: {
+      backgroundColor: colors.accent,
+    },
+    intentSubmitButton: {
+      backgroundColor: colors.accent,
+    },
+    intentActionButtonText: {
+      ...typography.button,
+      color: colors.textPrimary,
+    },
+    intentOptionsHeader: {
+      ...typography.caption,
+      textTransform: "uppercase",
+      color: colors.textSecondary,
+      marginBottom: spacing.xs,
+    },
+    intentOptionsList: {
+      maxHeight: 180,
+      marginBottom: spacing.md,
+    },
+    intentOptionRow: {
+      paddingVertical: spacing.sm,
+      borderBottomWidth: 1,
+      borderBottomColor: colors.border,
+    },
+    intentOptionLabel: {
+      ...typography.body,
+      color: colors.textPrimary,
+    },
+    intentOptionMeta: {
+      ...typography.caption,
+      color: colors.textSecondary,
+      marginTop: 2,
+    },
+    intentCustomRow: {
+      flexDirection: "row",
+      alignItems: "center",
+      gap: spacing.sm,
+      marginBottom: spacing.sm,
+    },
+    intentCustomInput: {
+      flex: 1,
+      borderWidth: 1,
+      borderColor: colors.border,
+      borderRadius: radii.sm,
+      paddingHorizontal: spacing.sm,
+      paddingVertical: spacing.xs,
+      color: colors.textPrimary,
+      backgroundColor: colors.surface,
+    },
+    intentSkipButton: {
+      alignItems: "center",
+      paddingVertical: spacing.sm,
+    },
+    intentSkipText: {
+      ...typography.caption,
+      color: colors.textSecondary,
+    },
   });
 
 const LoadingScreen: React.FC = () => {
@@ -601,7 +977,7 @@ const AuthenticatedApp: React.FC<{ session: Session }> = ({ session }) => {
   if (!onboardingComplete) {
     return (
       <OnboardingFlow
-        initialSettings={data.settings ?? undefined}
+        initialSettings={data.settings ?? null}
         initialTimezone={initialTimezone}
         onPersist={(state, timezone) =>
           save(state, timezone, "First-time onboarding", "onboarding")
diff --git a/src/components/Account.tsx b/src/components/Account.tsx
index 398b2f0..60de7c5 100644
--- a/src/components/Account.tsx
+++ b/src/components/Account.tsx
@@ -1,8 +1,62 @@
 import { useState, useEffect } from 'react'
-import { supabase } from '../lib/supabase'
-import { StyleSheet, View, Alert } from 'react-native'
-import { Button, Input } from '@rneui/themed'
+import { StyleSheet, View, Alert, Text, TextInput, Pressable } from 'react-native'
+import type { TextInputProps } from 'react-native'
 import { Session } from '@supabase/supabase-js'
+import { supabase } from '../lib/supabase'
+
+interface FieldProps {
+  label: string
+  value: string
+  onChangeText?: (value: string) => void
+  editable?: boolean
+  keyboardType?: TextInputProps['keyboardType']
+}
+
+const Field = ({
+  label,
+  value,
+  onChangeText,
+  editable = true,
+  keyboardType,
+}: FieldProps) => (
+  <View style={styles.field}>
+    <Text style={styles.fieldLabel}>{label}</Text>
+    <TextInput
+      style={[styles.input, !editable && styles.inputDisabled]}
+      value={value}
+      editable={editable}
+      onChangeText={onChangeText}
+      keyboardType={keyboardType}
+      autoCapitalize="none"
+      autoCorrect={false}
+      accessibilityLabel={label}
+    />
+  </View>
+)
+
+interface ActionButtonProps {
+  title: string
+  onPress: () => void
+  disabled?: boolean
+  tone?: 'primary' | 'danger' | 'neutral'
+}
+
+const ActionButton = ({ title, onPress, disabled = false, tone = 'primary' }: ActionButtonProps) => (
+  <Pressable
+    accessibilityRole="button"
+    accessibilityState={{ disabled }}
+    onPress={disabled ? undefined : onPress}
+    style={({ pressed }) => [
+      styles.button,
+      tone === 'danger' && styles.buttonDanger,
+      tone === 'neutral' && styles.buttonNeutral,
+      disabled && styles.buttonDisabled,
+      pressed && !disabled && styles.buttonPressed,
+    ]}
+  >
+    <Text style={styles.buttonText}>{title}</Text>
+  </Pressable>
+)
 
 export default function Account({ session }: { session: Session }) {
   const [loading, setLoading] = useState(true)
@@ -79,26 +133,28 @@ export default function Account({ session }: { session: Session }) {
 
   return (
     <View style={styles.container}>
-      <View style={[styles.verticallySpaced, styles.mt20]}>
-        <Input label="Email" value={session?.user?.email} disabled />
-      </View>
-      <View style={styles.verticallySpaced}>
-        <Input label="Username" value={username || ''} onChangeText={(text) => setUsername(text)} />
-      </View>
-      <View style={styles.verticallySpaced}>
-        <Input label="Website" value={website || ''} onChangeText={(text) => setWebsite(text)} />
-      </View>
+      <Field
+        label="Email"
+        value={session?.user?.email ?? ''}
+        editable={false}
+        keyboardType="email-address"
+      />
+      <Field label="Username" value={username} onChangeText={setUsername} />
+      <Field label="Website" value={website} onChangeText={setWebsite} />
 
-      <View style={[styles.verticallySpaced, styles.mt20]}>
-        <Button
-          title={loading ? 'Loading ...' : 'Update'}
+      <View style={styles.actions}>
+        <ActionButton
+          title={loading ? 'Updating…' : 'Update'}
           onPress={() => updateProfile({ username, website, avatar_url: avatarUrl })}
           disabled={loading}
         />
-      </View>
-
-      <View style={styles.verticallySpaced}>
-        <Button title="Sign Out" onPress={() => supabase.auth.signOut()} />
+        <ActionButton
+          title="Sign Out"
+          onPress={() => {
+            void supabase.auth.signOut()
+          }}
+          tone="danger"
+        />
       </View>
     </View>
   )
@@ -107,14 +163,55 @@ export default function Account({ session }: { session: Session }) {
 const styles = StyleSheet.create({
   container: {
     marginTop: 40,
-    padding: 12,
+    padding: 16,
+    gap: 16,
+  },
+  field: {
+    gap: 6,
+  },
+  fieldLabel: {
+    fontSize: 14,
+    fontWeight: '600',
+    color: '#9CA3AF',
+  },
+  input: {
+    borderRadius: 12,
+    borderWidth: 1,
+    borderColor: '#1F2937',
+    paddingHorizontal: 16,
+    paddingVertical: 12,
+    fontSize: 16,
+    color: '#FFFFFF',
+    backgroundColor: '#111827',
+  },
+  inputDisabled: {
+    backgroundColor: '#1F2937',
+    color: '#9CA3AF',
+  },
+  actions: {
+    gap: 12,
+  },
+  button: {
+    borderRadius: 12,
+    paddingVertical: 14,
+    alignItems: 'center',
+    backgroundColor: '#6366F1',
+  },
+  buttonDanger: {
+    backgroundColor: '#EF4444',
+  },
+  buttonNeutral: {
+    backgroundColor: '#4B5563',
+  },
+  buttonDisabled: {
+    opacity: 0.5,
   },
-  verticallySpaced: {
-    paddingTop: 4,
-    paddingBottom: 4,
-    alignSelf: 'stretch',
+  buttonPressed: {
+    transform: [{ scale: 0.98 }],
   },
-  mt20: {
-    marginTop: 20,
+  buttonText: {
+    color: '#FFFFFF',
+    fontSize: 16,
+    fontWeight: '600',
   },
-})
\ No newline at end of file
+})
diff --git a/src/components/MenuList.tsx b/src/components/MenuList.tsx
index 46a0a1d..73ec0d0 100644
--- a/src/components/MenuList.tsx
+++ b/src/components/MenuList.tsx
@@ -29,6 +29,7 @@ interface MenuListProps {
   onSelectType: (type: EntryType) => void;
   onSelectEntry: (entryId: string) => void;
   onEntriesUpdate: (entries: RemoteJournalEntry[]) => void;
+  onShowHistory?: () => void;
 }
 
 const ENTRY_TYPE_LABELS: Record<EntryType, string> = {
@@ -59,6 +60,7 @@ const MenuList: React.FC<MenuListProps> = ({
   onSelectType,
   onSelectEntry,
   onEntriesUpdate,
+  onShowHistory,
 }) => {
   const { themeMode } = useTheme();
   const colors = getColors(themeMode);
@@ -80,10 +82,11 @@ const MenuList: React.FC<MenuListProps> = ({
             onPress: async () => {
               try {
                 await deleteJournalEntry(id);
-                const updatedEntries = await listJournals({
-                  type: selectedType!,
-                  limit: 100,
-                });
+                const updatedEntries = await listJournals(
+                  selectedType
+                    ? { type: selectedType, limit: 100 }
+                    : { limit: 100 }
+                );
                 onEntriesUpdate(updatedEntries);
               } catch (error) {
                 console.error("Error deleting entry:", error);
@@ -119,9 +122,8 @@ const MenuList: React.FC<MenuListProps> = ({
             onPress: async () => {
               try {
                 await deleteAllEntriesByType(type);
-                // Refresh the entries list
                 const updatedEntries = await listJournals({
-                  type: selectedType!,
+                  type,
                   limit: 100,
                 });
                 onEntriesUpdate(updatedEntries);
@@ -208,6 +210,24 @@ const MenuList: React.FC<MenuListProps> = ({
         {(["goal", "journal", "schedule"] as EntryType[]).map(
           renderCategoryItem
         )}
+        <TouchableOpacity
+          style={[styles.categoryButton, styles.historyButton]}
+          onPress={onShowHistory ?? (() => undefined)}
+        >
+          <View style={styles.categoryIconContainer}>
+            <Ionicons
+              name="time-outline"
+              size={18}
+              color={colors.accent}
+            />
+          </View>
+          <View style={styles.categoryTextContainer}>
+            <Text style={styles.categoryButtonText}>Main History</Text>
+            <Text style={styles.categoryCountText}>
+              View archived conversations
+            </Text>
+          </View>
+        </TouchableOpacity>
       </View>
     );
   }
@@ -286,6 +306,10 @@ const createStyles = (colors: any) =>
       borderLeftWidth: 2,
       borderLeftColor: "transparent",
     },
+    historyButton: {
+      marginTop: spacing.lg,
+      borderLeftColor: colors.accent,
+    },
     categoryIconContainer: {
       width: 32,
       height: 32,
diff --git a/src/components/ScheduleCalendarModal.tsx b/src/components/ScheduleCalendarModal.tsx
index eed1a85..1807200 100644
--- a/src/components/ScheduleCalendarModal.tsx
+++ b/src/components/ScheduleCalendarModal.tsx
@@ -13,6 +13,8 @@ import { Ionicons } from "@expo/vector-icons";
 import { getColors, radii, spacing, typography, shadows } from "../theme";
 import { useTheme } from "../contexts/ThemeContext";
 import { listJournals, type RemoteJournalEntry } from "../services/data";
+import MenuEntryChat from "./menu/MenuEntryChat";
+import { useEntryChat } from "../hooks/useEntryChat";
 
 interface ScheduleCalendarModalProps {
   visible: boolean;
@@ -86,9 +88,51 @@ const parseScheduleContent = (content: string) => {
   return { place, time, reason };
 };
 
+const parseDateFromString = (value?: string | null): Date | null => {
+  if (!value) return null;
+  const trimmed = value.trim();
+  if (!trimmed) return null;
+
+  const isoMatch = trimmed.match(/\d{4}-\d{2}-\d{2}/);
+  if (isoMatch) {
+    const date = new Date(`${isoMatch[0]}T00:00:00`);
+    if (!Number.isNaN(date.getTime())) {
+      return date;
+    }
+  }
+
+  const parsed = Date.parse(trimmed);
+  if (!Number.isNaN(parsed)) {
+    const date = new Date(parsed);
+    if (!Number.isNaN(date.getTime())) {
+      return date;
+    }
+  }
+
+  return null;
+};
+
+const resolveEntryDate = (entry: RemoteJournalEntry): Date => {
+  if (entry.type === "schedule") {
+    const metadata = (entry.metadata ?? {}) as Record<string, any>;
+    const metadataDate = parseDateFromString(metadata?.scheduled_for);
+    if (metadataDate) {
+      return metadataDate;
+    }
+
+    const { time } = parseScheduleContent(entry.content ?? "");
+    const parsed = parseDateFromString(time);
+    if (parsed) {
+      return parsed;
+    }
+  }
+
+  return new Date(entry.created_at ?? Date.now());
+};
+
 const groupEntriesByDate = (entries: RemoteJournalEntry[]) => {
   return entries.reduce<EntryGroups>((acc, entry) => {
-    const key = formatDateKey(entry.created_at);
+    const key = formatDateKey(resolveEntryDate(entry));
     if (!acc[key]) {
       acc[key] = [];
     }
@@ -111,27 +155,20 @@ const ScheduleCalendarModal: React.FC<ScheduleCalendarModalProps> = ({
   const [entries, setEntries] = useState<RemoteJournalEntry[]>([]);
   const [loading, setLoading] = useState(false);
   const [error, setError] = useState<string | null>(null);
+  const [selectedScheduleId, setSelectedScheduleId] = useState<string | null>(
+    null
+  );
 
   const scheduleEntries = useMemo(
     () => entries.filter((entry) => entry.type === "schedule"),
     [entries]
   );
 
-  const reflectionEntries = useMemo(
-    () => entries.filter((entry) => entry.type !== "schedule"),
-    [entries]
-  );
-
   const scheduleByDate = useMemo(
     () => groupEntriesByDate(scheduleEntries),
     [scheduleEntries]
   );
 
-  const reflectionsByDate = useMemo(
-    () => groupEntriesByDate(reflectionEntries),
-    [reflectionEntries]
-  );
-
   const fetchEntries = useCallback(async () => {
     setLoading(true);
     setError(null);
@@ -161,9 +198,31 @@ const ScheduleCalendarModal: React.FC<ScheduleCalendarModalProps> = ({
     setCurrentCursor(selectedDate);
   }, [selectedDate, visible]);
 
-  const handleSelectDate = useCallback((day: Date) => {
-    setSelectedDate(day);
-  }, []);
+  useEffect(() => {
+    if (!visible) return;
+    const key = formatDateKey(selectedDate);
+    const entriesForDay = scheduleByDate[key] ?? [];
+    if (entriesForDay.length === 0) {
+      if (selectedScheduleId !== null) {
+        setSelectedScheduleId(null);
+      }
+      return;
+    }
+
+    if (!entriesForDay.some((entry) => entry.id === selectedScheduleId)) {
+      setSelectedScheduleId(entriesForDay[0]?.id ?? null);
+    }
+  }, [visible, selectedDate, scheduleByDate, selectedScheduleId]);
+
+  const handleSelectDate = useCallback(
+    (day: Date) => {
+      setSelectedDate(day);
+      const key = formatDateKey(day);
+      const entriesForDay = scheduleByDate[key] ?? [];
+      setSelectedScheduleId(entriesForDay[0]?.id ?? null);
+    },
+    [scheduleByDate]
+  );
 
   const handleChangeWeek = useCallback((direction: -1 | 1) => {
     setCurrentCursor((prev) => addDays(prev, direction * 7));
@@ -175,7 +234,16 @@ const ScheduleCalendarModal: React.FC<ScheduleCalendarModalProps> = ({
 
   const selectedDateKey = formatDateKey(selectedDate);
   const itinerary = scheduleByDate[selectedDateKey] ?? [];
-  const reflections = reflectionsByDate[selectedDateKey] ?? [];
+
+  const {
+    selectedEntry: scheduleEntry,
+    annotations: scheduleAnnotations,
+    annotationsLoading,
+    annotationsError,
+    setAnnotations: setScheduleAnnotations,
+    onErrorUpdate: setScheduleChatError,
+    refreshAnnotations: refreshScheduleAnnotations,
+  } = useEntryChat(selectedScheduleId, visible);
 
   const renderDayCell = (day: Date, isCurrentMonth = true) => {
     const dayKey = formatDateKey(day);
@@ -208,6 +276,14 @@ const ScheduleCalendarModal: React.FC<ScheduleCalendarModalProps> = ({
 
   const weekDays = useMemo(() => buildWeek(currentCursor), [currentCursor]);
   const monthDays = useMemo(() => buildMonth(currentCursor), [currentCursor]);
+  const weekRangeLabel = useMemo(() => {
+    const start = weekDays[0];
+    const end = weekDays[6];
+    if (start && end) {
+      return `${formatMonthTitle(start)} — ${formatMonthTitle(end)}`;
+    }
+    return formatMonthTitle(currentCursor);
+  }, [weekDays, currentCursor]);
 
   return (
     <Modal
@@ -289,7 +365,7 @@ const ScheduleCalendarModal: React.FC<ScheduleCalendarModalProps> = ({
               </TouchableOpacity>
               <Text style={styles.calendarHeaderTitle}>
                 {viewMode === "week"
-                  ? `${formatMonthTitle(weekDays[0])} — ${formatMonthTitle(weekDays[6])}`
+                  ? weekRangeLabel
                   : formatMonthTitle(currentCursor)}
               </Text>
               <TouchableOpacity
@@ -351,90 +427,93 @@ const ScheduleCalendarModal: React.FC<ScheduleCalendarModalProps> = ({
                 <Text style={styles.errorText}>{error}</Text>
               </View>
             ) : (
-              <>
-                <View style={styles.section}>
-                  <Text style={styles.sectionTitle}>Itinerary</Text>
-                  {itinerary.length === 0 ? (
-                    <Text style={styles.emptyText}>
-                      No schedules yet for this day. Use + Schedule to add one.
-                    </Text>
-                  ) : (
-                    itinerary.map((entry) => {
-                      const { place, time, reason } = parseScheduleContent(
-                        entry.content
-                      );
-                      return (
-                        <View key={entry.id} style={styles.scheduleCard}>
-                          <View style={styles.scheduleRow}>
-                            <Ionicons
-                              name="location-outline"
-                              size={16}
-                              color={colors.accent}
-                            />
-                            <Text style={styles.scheduleValue}>
-                              {place || "Tap to set place in chat"}
-                            </Text>
-                          </View>
-                          <View style={styles.scheduleRow}>
-                            <Ionicons
-                              name="time-outline"
-                              size={16}
-                              color={colors.textSecondary}
-                            />
-                            <Text style={styles.scheduleValue}>
-                              {time || "Add a time"}
-                            </Text>
-                          </View>
-                          <View style={styles.scheduleRow}>
-                            <Ionicons
-                              name="chatbubble-ellipses-outline"
-                              size={16}
-                              color={colors.textSecondary}
-                            />
-                            <Text style={styles.scheduleValue}>
-                              {reason || "Note a reason or intention"}
+              <View style={styles.section}>
+                <Text style={styles.sectionTitle}>Itinerary</Text>
+                {itinerary.length === 0 ? (
+                  <Text style={styles.emptyText}>
+                    No schedules yet for this day. Use + Schedule to add one.
+                  </Text>
+                ) : (
+                  itinerary.map((entry) => {
+                    const { place, time, reason } = parseScheduleContent(
+                      entry.content
+                    );
+                    const isActive = entry.id === selectedScheduleId;
+                    return (
+                      <TouchableOpacity
+                        key={entry.id}
+                        style={[
+                          styles.scheduleCard,
+                          isActive && styles.scheduleCardActive,
+                        ]}
+                        onPress={() => setSelectedScheduleId(entry.id)}
+                      >
+                        <View style={styles.scheduleRow}>
+                          <Ionicons
+                            name="location-outline"
+                            size={16}
+                            color={colors.accent}
+                          />
+                          <Text style={styles.scheduleValue}>
+                            {place || "Tap to set place in chat"}
+                          </Text>
+                        </View>
+                        <View style={styles.scheduleRow}>
+                          <Ionicons
+                            name="time-outline"
+                            size={16}
+                            color={colors.textSecondary}
+                          />
+                          <Text style={styles.scheduleValue}>
+                            {time || "Add a time"}
+                          </Text>
+                        </View>
+                        <View style={styles.scheduleRow}>
+                          <Ionicons
+                            name="chatbubble-ellipses-outline"
+                            size={16}
+                            color={colors.textSecondary}
+                          />
+                          <Text style={styles.scheduleValue}>
+                            {reason || "Note a reason or intention"}
+                          </Text>
+                        </View>
+                        {entry.ai_meta?.rationale && (
+                          <View style={styles.metaBox}>
+                            <Text style={styles.metaLabel}>AI Insight</Text>
+                            <Text style={styles.metaValue}>
+                              {String(entry.ai_meta.rationale)}
                             </Text>
                           </View>
-                          {entry.ai_meta?.rationale && (
-                            <View style={styles.metaBox}>
-                              <Text style={styles.metaLabel}>AI Insight</Text>
-                              <Text style={styles.metaValue}>
-                                {String(entry.ai_meta.rationale)}
-                              </Text>
-                            </View>
-                          )}
-                        </View>
-                      );
-                    })
-                  )}
-                </View>
-
-                <View style={styles.section}>
-                  <Text style={styles.sectionTitle}>Linked Reflections</Text>
-                  {reflections.length === 0 ? (
-                    <Text style={styles.emptyText}>
-                      No journal or goal entries from this day yet.
-                    </Text>
-                  ) : (
-                    reflections.map((entry) => (
-                      <View key={entry.id} style={styles.reflectionCard}>
-                        <Text style={styles.reflectionType}>
-                          {entry.type === "goal"
-                            ? "Goal"
-                            : entry.type === "journal"
-                              ? "Journal"
-                              : "Schedule"}
-                        </Text>
-                        <Text style={styles.reflectionContent}>
-                          {entry.content}
-                        </Text>
-                      </View>
-                    ))
-                  )}
-                </View>
-              </>
+                        )}
+                      </TouchableOpacity>
+                    );
+                  })
+                )}
+              </View>
             )}
           </ScrollView>
+
+          <View style={styles.entryChatContainer}>
+            {selectedScheduleId && scheduleEntry ? (
+              <MenuEntryChat
+                entry={scheduleEntry}
+                annotations={scheduleAnnotations}
+                loading={annotationsLoading}
+                error={annotationsError}
+                onAnnotationsUpdate={setScheduleAnnotations}
+                onAnnotationCountUpdate={() => undefined}
+                onErrorUpdate={setScheduleChatError}
+                onRefreshAnnotations={refreshScheduleAnnotations}
+              />
+            ) : (
+              <View style={styles.emptyChatContainer}>
+                <Text style={styles.emptyText}>
+                  Select a schedule to open notes and AI coaching.
+                </Text>
+              </View>
+            )}
+          </View>
         </SafeAreaView>
       </View>
     </Modal>
@@ -637,6 +716,12 @@ const createStyles = (colors: any) =>
       padding: spacing.md,
       marginBottom: spacing.sm,
     },
+    scheduleCardActive: {
+      borderColor: colors.accent,
+      shadowColor: colors.accent,
+      shadowOpacity: 0.2,
+      shadowRadius: 8,
+    },
     scheduleRow: {
       flexDirection: "row",
       alignItems: "center",
@@ -668,25 +753,17 @@ const createStyles = (colors: any) =>
       color: colors.textPrimary,
       fontSize: 13,
     },
-    reflectionCard: {
-      padding: spacing.md,
-      borderRadius: radii.md,
-      backgroundColor: colors.surface,
+    entryChatContainer: {
+      marginTop: spacing.lg,
+      borderRadius: radii.lg,
       borderWidth: 1,
       borderColor: colors.border,
-      marginBottom: spacing.sm,
-    },
-    reflectionType: {
-      fontFamily: typography.caption.fontFamily,
-      fontSize: 12,
-      textTransform: "uppercase",
-      color: colors.textSecondary,
-      marginBottom: 4,
+      backgroundColor: colors.surface,
+      overflow: "hidden",
+      maxHeight: 520,
     },
-    reflectionContent: {
-      fontFamily: typography.body.fontFamily,
-      color: colors.textPrimary,
-      fontSize: 14,
+    emptyChatContainer: {
+      padding: spacing.md,
     },
   });
 
diff --git a/src/components/menu/MenuEntryChat.tsx b/src/components/menu/MenuEntryChat.tsx
index 31eb8a9..f5dd2ab 100644
--- a/src/components/menu/MenuEntryChat.tsx
+++ b/src/components/menu/MenuEntryChat.tsx
@@ -20,6 +20,9 @@ import type { RemoteJournalEntry, EntryType } from "../../services/data";
 import { appendMessage } from "../../services/data";
 import { supabase } from "../../lib/supabase";
 import { generateAIResponse, formatAnnotationLabel } from "../../services/ai";
+import { predictIntent, isEntryChatAllowed } from "../../lib/intent";
+import type { IntentPredictionResult, ProcessingStep } from "../../types/intent";
+import type { ProcessingStepId } from "../../types/intent";
 import { getColors, radii, spacing, typography, shadows } from "../../theme";
 import { useTheme } from "../../contexts/ThemeContext";
 
@@ -38,6 +41,36 @@ interface MenuEntryChatProps {
 
 type ComposerMode = "note" | "ai";
 
+const createProcessingTimeline = (): ProcessingStep[] => [
+  { id: "ml_detection", label: "ML prediction", status: "pending" },
+  { id: "knowledge_search", label: "Knowledge base", status: "pending" },
+  { id: "openai_request", label: "OpenAI request", status: "pending" },
+  { id: "openai_response", label: "OpenAI received", status: "pending" },
+];
+
+const updateTimelineStep = (
+  timeline: ProcessingStep[],
+  stepId: ProcessingStepId,
+  status: ProcessingStep["status"],
+  detail?: string
+): ProcessingStep[] =>
+  timeline.map((step) => {
+    if (step.id !== stepId) {
+      return step;
+    }
+    const next: ProcessingStep = {
+      ...step,
+      status,
+      timestamp: new Date().toISOString(),
+    };
+    if (detail !== undefined) {
+      next.detail = detail;
+    } else {
+      delete next.detail;
+    }
+    return next;
+  });
+
 const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
   entry,
   annotations,
@@ -58,10 +91,17 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
   const [composerText, setComposerText] = useState("");
   const [isSavingNote, setIsSavingNote] = useState(false);
   const [isWorkingWithAI, setIsWorkingWithAI] = useState(false);
+  const [processingSteps, setProcessingSteps] = useState<ProcessingStep[]>([]);
+  const [predictedIntent, setPredictedIntent] =
+    useState<IntentPredictionResult | null>(null);
 
   // Notify parent component when mode changes
   useEffect(() => {
     onModeChange?.(composerMode);
+    if (composerMode === "note") {
+      setProcessingSteps([]);
+      setPredictedIntent(null);
+    }
   }, [composerMode, onModeChange]);
 
   const handleAddNote = useCallback(async () => {
@@ -113,10 +153,68 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
     setIsWorkingWithAI(true);
     onErrorUpdate(null);
 
+    let timeline = createProcessingTimeline();
+    setProcessingSteps(timeline);
+
+    const setTimeline = (
+      stepId: ProcessingStepId,
+      status: ProcessingStep["status"],
+      detail?: string
+    ) => {
+      timeline = updateTimelineStep(timeline, stepId, status, detail);
+      setProcessingSteps(timeline);
+    };
+
     try {
+      setTimeline("ml_detection", "running", "Analyzing");
+      const prediction = await predictIntent(trimmed);
+      setPredictedIntent(prediction);
+
+      setTimeline(
+        "ml_detection",
+        "done",
+        `${prediction.rawLabel} ${(prediction.confidence * 100).toFixed(1)}%`
+      );
+
+      if (!isEntryChatAllowed(prediction.id)) {
+        setTimeline(
+          "knowledge_search",
+          "skipped",
+          "Redirect required"
+        );
+        setTimeline(
+          "openai_request",
+          "skipped",
+          "Use main chat"
+        );
+        setTimeline(
+          "openai_response",
+          "skipped",
+          "Intent restricted"
+        );
+        onErrorUpdate(
+          "This intent is managed from Main Chat. Switch surfaces to continue."
+        );
+        Alert.alert(
+          "Open Main Chat",
+          "This type of request is routed through the main chat so Riflett can manage linked data."
+        );
+        return;
+      }
+
+      setTimeline("knowledge_search", "done", "Entry context ready");
+
       const userMessage = await appendMessage(entryId, "user", trimmed, {
         channel: "ai",
         messageKind: "aiQuestion",
+        intent: {
+          id: prediction.id,
+          label: prediction.label,
+          rawLabel: prediction.rawLabel,
+          confidence: prediction.confidence,
+          subsystem: prediction.subsystem,
+        },
+        processingTimeline: timeline,
       });
 
       const userAnnotation: Annotation = {
@@ -126,18 +224,38 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
         channel: "ai",
         content: userMessage.content,
         created_at: userMessage.created_at,
+        metadata: {
+          intent: {
+            id: prediction.id,
+            label: prediction.label,
+            confidence: prediction.confidence,
+            subsystem: prediction.subsystem,
+          },
+          processingTimeline: timeline,
+        },
       };
 
       const updatedAnnotations = [...annotations, userAnnotation];
       onAnnotationsUpdate(updatedAnnotations);
 
+      setTimeline("openai_request", "running", "Sending prompt");
+
       const aiResult = await generateAIResponse({
         entryContent: entry.content,
         annotations: updatedAnnotations,
         userMessage: trimmed,
         entryType: entry.type,
+        intentContext: {
+          id: prediction.id,
+          label: prediction.label,
+          confidence: prediction.confidence,
+          subsystem: prediction.subsystem,
+        },
       });
 
+      setTimeline("openai_request", "done", "Prompt dispatched");
+      setTimeline("openai_response", "done", "Response captured");
+
       const botMessage = await appendMessage(
         entryId,
         "assistant",
@@ -147,6 +265,14 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
           messageKind: "aiReply",
           learned: aiResult.learned,
           ethical: aiResult.ethical,
+          intent: {
+            id: prediction.id,
+            label: prediction.label,
+            rawLabel: prediction.rawLabel,
+            confidence: prediction.confidence,
+            subsystem: prediction.subsystem,
+          },
+          processingTimeline: timeline,
         }
       );
 
@@ -157,6 +283,16 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
         channel: "ai",
         content: botMessage.content,
         created_at: botMessage.created_at,
+        metadata: {
+          learned: aiResult.learned,
+          ethical: aiResult.ethical,
+          intent: {
+            id: prediction.id,
+            label: prediction.label,
+            confidence: prediction.confidence,
+          },
+          processingTimeline: timeline,
+        },
       };
 
       onAnnotationsUpdate([...updatedAnnotations, botAnnotation]);
@@ -164,6 +300,13 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
       setComposerText("");
     } catch (error) {
       console.error("Error requesting AI guidance", error);
+      setTimeline(
+        "openai_response",
+        "error",
+        error instanceof Error
+          ? error.message
+          : "Unable to contact AI"
+      );
       onErrorUpdate(
         error instanceof Error
           ? error.message
@@ -177,7 +320,6 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
     composerText,
     entry,
     onAnnotationsUpdate,
-    onAnnotationCountUpdate,
     onErrorUpdate,
   ]);
 
@@ -191,8 +333,8 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
       return (
         <Pressable
           style={({ pressed }) => [
-            styles.noteEntry,
-            pressed && styles.noteEntryPressed,
+            styles.noteEntryWrapper,
+            pressed && styles.noteEntryWrapperPressed,
           ]}
           onLongPress={() => {
             if (item.id) {
@@ -201,14 +343,23 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
           }}
           delayLongPress={500}
         >
-          <View style={styles.noteContent}>
-            <Text style={styles.noteText}>{item.content}</Text>
-            {item.created_at && (
-              <Text style={styles.noteTimestamp}>
-                {new Date(item.created_at).toLocaleDateString()}
-              </Text>
-            )}
-          </View>
+          {({ pressed }) => (
+            <View
+              style={[
+                styles.noteEntryInner,
+                pressed && styles.noteEntryInnerPressed,
+              ]}
+            >
+              <View style={styles.noteContent}>
+                <Text style={styles.noteText}>{item.content}</Text>
+                {item.created_at && (
+                  <Text style={styles.noteTimestamp}>
+                    {new Date(item.created_at).toLocaleDateString()}
+                  </Text>
+                )}
+              </View>
+            </View>
+          )}
         </Pressable>
       );
     }
@@ -223,41 +374,52 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
       >
         <View
           style={[
-            styles.annotationBubble,
-            isUser ? styles.annotationBubbleUser : styles.annotationBubbleOther,
+            styles.annotationBubbleWrapper,
+            isUser
+              ? styles.annotationBubbleWrapperUser
+              : styles.annotationBubbleWrapperOther,
           ]}
         >
-          <Text
+          <View
             style={[
-              styles.annotationLabel,
-              isUser ? styles.annotationLabelUser : styles.annotationLabelOther,
+              styles.annotationBubble,
+              isUser ? styles.annotationBubbleUser : styles.annotationBubbleOther,
             ]}
           >
-            {label}
-          </Text>
-          <Text
-            style={[
-              styles.annotationText,
-              isUser ? styles.annotationTextUser : styles.annotationTextOther,
-            ]}
-          >
-            {item.content}
-          </Text>
-          {item.created_at && (
             <Text
               style={[
-                styles.annotationTimestamp,
+                styles.annotationLabel,
                 isUser
-                  ? styles.annotationTimestampUser
-                  : styles.annotationTimestampOther,
+                  ? styles.annotationLabelUser
+                  : styles.annotationLabelOther,
               ]}
             >
-              {new Date(item.created_at).toLocaleTimeString([], {
-                hour: "2-digit",
-                minute: "2-digit",
-              })}
+              {label}
             </Text>
-          )}
+            <Text
+              style={[
+                styles.annotationText,
+                isUser ? styles.annotationTextUser : styles.annotationTextOther,
+              ]}
+            >
+              {item.content}
+            </Text>
+            {item.created_at && (
+              <Text
+                style={[
+                  styles.annotationTimestamp,
+                  isUser
+                    ? styles.annotationTimestampUser
+                    : styles.annotationTimestampOther,
+                ]}
+              >
+                {new Date(item.created_at).toLocaleTimeString([], {
+                  hour: "2-digit",
+                  minute: "2-digit",
+                })}
+              </Text>
+            )}
+          </View>
         </View>
       </View>
     );
@@ -419,38 +581,54 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
 
       <View style={styles.noteInputRow}>
         <View style={styles.modeSwitcher}>
-          <TouchableOpacity
+          <Pressable
             onPress={() => setComposerMode("note")}
-            style={[
-              styles.modeButton,
-              composerMode === "note" && styles.modeButtonActive,
+            style={({ pressed }) => [
+              styles.modeButtonWrapper,
+              composerMode === "note" && styles.modeButtonWrapperActive,
+              pressed && styles.modeButtonWrapperPressed,
             ]}
           >
-            <Text
+            <View
               style={[
-                styles.modeButtonText,
-                composerMode === "note" && styles.modeButtonTextActive,
+                styles.modeButton,
+                composerMode === "note" && styles.modeButtonActive,
               ]}
             >
-              Note
-            </Text>
-          </TouchableOpacity>
-          <TouchableOpacity
+              <Text
+                style={[
+                  styles.modeButtonText,
+                  composerMode === "note" && styles.modeButtonTextActive,
+                ]}
+              >
+                Note
+              </Text>
+            </View>
+          </Pressable>
+          <Pressable
             onPress={() => setComposerMode("ai")}
-            style={[
-              styles.modeButton,
-              composerMode === "ai" && styles.modeButtonActive,
+            style={({ pressed }) => [
+              styles.modeButtonWrapper,
+              composerMode === "ai" && styles.modeButtonWrapperActive,
+              pressed && styles.modeButtonWrapperPressed,
             ]}
           >
-            <Text
+            <View
               style={[
-                styles.modeButtonText,
-                composerMode === "ai" && styles.modeButtonTextActive,
+                styles.modeButton,
+                composerMode === "ai" && styles.modeButtonActive,
               ]}
             >
-              AI
-            </Text>
-          </TouchableOpacity>
+              <Text
+                style={[
+                  styles.modeButtonText,
+                  composerMode === "ai" && styles.modeButtonTextActive,
+                ]}
+              >
+                AI
+              </Text>
+            </View>
+          </Pressable>
         </View>
         <View style={styles.inputRow}>
           <TextInput
@@ -465,28 +643,61 @@ const MenuEntryChat: React.FC<MenuEntryChatProps> = ({
             placeholderTextColor="rgba(244,244,244,0.6)"
             multiline
           />
-          <TouchableOpacity
+          <View
             style={[
-              styles.noteSendButton,
-              ((composerMode === "note" && disableNoteSend) ||
-                (composerMode === "ai" && disableAISend)) &&
-                styles.noteSendButtonDisabled,
+              styles.noteSendWrapper,
+              composerMode === "ai" && styles.noteSendWrapperAI,
             ]}
-            onPress={composerMode === "note" ? handleAddNote : handleAskAI}
-            disabled={composerMode === "note" ? disableNoteSend : disableAISend}
           >
-            <Ionicons
-              name="arrow-up"
-              size={20}
-              color={
-                (composerMode === "note" && disableNoteSend) ||
-                (composerMode === "ai" && disableAISend)
-                  ? colors.textTertiary
-                  : colors.textPrimary
+            <TouchableOpacity
+              style={[
+                styles.noteSendButton,
+                ((composerMode === "note" && disableNoteSend) ||
+                  (composerMode === "ai" && disableAISend)) &&
+                  styles.noteSendButtonDisabled,
+              ]}
+              onPress={
+                composerMode === "note" ? handleAddNote : handleAskAI
+              }
+              disabled={
+                composerMode === "note" ? disableNoteSend : disableAISend
               }
-            />
-          </TouchableOpacity>
+            >
+              <Ionicons
+                name="arrow-up"
+                size={20}
+                color={
+                  (composerMode === "note" && disableNoteSend) ||
+                  (composerMode === "ai" && disableAISend)
+                    ? colors.textTertiary
+                    : colors.textPrimary
+                }
+              />
+            </TouchableOpacity>
+          </View>
         </View>
+        {composerMode === "ai" && predictedIntent && (
+          <Text style={styles.intentSummary}>
+            {`Intent: ${predictedIntent.label} (${Math.round(
+              predictedIntent.confidence * 100
+            )}% confidence)`}
+          </Text>
+        )}
+        {composerMode === "ai" && processingSteps.length > 0 && (
+          <View style={styles.processingRow}>
+            {processingSteps.map((step) => (
+              <View
+                key={step.id}
+                style={[
+                  styles.processingChip,
+                  styles[`processing_${step.status}` as const],
+                ]}
+              >
+                <Text style={styles.processingText}>{step.label}</Text>
+              </View>
+            ))}
+          </View>
+        )}
       </View>
     </KeyboardAvoidingView>
   );
@@ -521,18 +732,24 @@ const createStyles = (colors: any, insets: any) =>
       borderTopWidth: 1,
       borderTopColor: colors.border,
     },
-    noteEntry: {
-      backgroundColor: colors.surface,
+    noteEntryWrapper: {
       borderRadius: radii.md,
       marginBottom: spacing.sm,
+      backgroundColor: colors.background,
+      ...shadows.glass,
+    },
+    noteEntryWrapperPressed: {
+      transform: [{ scale: 0.98 }],
+    },
+    noteEntryInner: {
+      backgroundColor: colors.surface,
+      borderRadius: radii.md,
       borderWidth: 1,
       borderColor: colors.border,
       overflow: "hidden",
-      ...shadows.glass,
     },
-    noteEntryPressed: {
+    noteEntryInnerPressed: {
       backgroundColor: colors.surfaceElevated,
-      transform: [{ scale: 0.98 }],
     },
     noteContent: {
       padding: spacing.md,
@@ -630,8 +847,15 @@ const createStyles = (colors: any, insets: any) =>
     annotationRowOther: {
       justifyContent: "flex-start",
     },
-    annotationBubble: {
+    annotationBubbleWrapper: {
       maxWidth: "80%",
+      borderRadius: radii.md,
+      backgroundColor: colors.background,
+      ...shadows.glass,
+    },
+    annotationBubbleWrapperUser: {},
+    annotationBubbleWrapperOther: {},
+    annotationBubble: {
       paddingHorizontal: spacing.md,
       paddingVertical: spacing.md,
       borderRadius: radii.md,
@@ -640,13 +864,11 @@ const createStyles = (colors: any, insets: any) =>
       backgroundColor: colors.surfaceElevated,
       borderWidth: 1,
       borderColor: colors.accent,
-      ...shadows.glass,
     },
     annotationBubbleOther: {
       backgroundColor: colors.surface,
       borderWidth: 1,
       borderColor: colors.border,
-      ...shadows.glass,
     },
     annotationLabel: {
       fontFamily: typography.caption.fontFamily,
@@ -700,20 +922,29 @@ const createStyles = (colors: any, insets: any) =>
       flexDirection: "row",
       marginBottom: spacing.sm,
     },
+    modeButtonWrapper: {
+      marginRight: spacing.sm,
+      borderRadius: radii.md,
+      backgroundColor: colors.background,
+      ...shadows.glass,
+    },
+    modeButtonWrapperActive: {
+      ...shadows.glow,
+    },
+    modeButtonWrapperPressed: {
+      transform: [{ scale: 0.98 }],
+    },
     modeButton: {
       paddingVertical: spacing.sm,
       paddingHorizontal: spacing.md,
       borderRadius: radii.md,
       borderWidth: 1,
       borderColor: colors.border,
-      marginRight: spacing.sm,
       backgroundColor: colors.surface,
-      ...shadows.glass,
     },
     modeButtonActive: {
       borderColor: colors.accent,
       backgroundColor: colors.surfaceElevated,
-      ...shadows.glow,
     },
     modeButtonText: {
       fontFamily: typography.button.fontFamily,
@@ -743,6 +974,14 @@ const createStyles = (colors: any, insets: any) =>
       borderColor: colors.border,
       marginRight: spacing.sm,
     },
+    noteSendWrapper: {
+      borderRadius: radii.md,
+      backgroundColor: colors.background,
+      ...shadows.glass,
+    },
+    noteSendWrapperAI: {
+      ...shadows.glow,
+    },
     noteSendButton: {
       backgroundColor: colors.accent,
       borderRadius: radii.md,
@@ -752,12 +991,53 @@ const createStyles = (colors: any, insets: any) =>
       borderColor: colors.accent,
       justifyContent: "center",
       alignItems: "center",
-      ...shadows.glass,
     },
     noteSendButtonDisabled: {
       borderColor: colors.borderLight,
       backgroundColor: colors.surface,
     },
+    intentSummary: {
+      marginTop: spacing.sm,
+      ...typography.caption,
+      fontSize: 12,
+      color: colors.textSecondary,
+    },
+    processingRow: {
+      flexDirection: "row",
+      flexWrap: "wrap",
+      gap: spacing.xs,
+      marginTop: spacing.xs,
+    },
+    processingChip: {
+      paddingHorizontal: spacing.sm,
+      paddingVertical: spacing.xs,
+      borderRadius: radii.pill,
+      borderWidth: 1,
+      borderColor: colors.border,
+      backgroundColor: colors.surface,
+    },
+    processing_pending: {
+      borderColor: colors.border,
+    },
+    processing_running: {
+      borderColor: colors.accent,
+    },
+    processing_done: {
+      borderColor: colors.success,
+    },
+    processing_error: {
+      borderColor: colors.error,
+    },
+    processing_skipped: {
+      borderColor: colors.border,
+      opacity: 0.6,
+    },
+    processingText: {
+      ...typography.caption,
+      fontSize: 10,
+      color: colors.textPrimary,
+      textTransform: "uppercase",
+    },
   });
 
 export default MenuEntryChat;
diff --git a/src/hooks/useChatState.ts b/src/hooks/useChatState.ts
index 4341857..7a94f7a 100644
--- a/src/hooks/useChatState.ts
+++ b/src/hooks/useChatState.ts
@@ -10,7 +10,29 @@ import {
   listJournals,
   type EntryType,
 } from "../services/data";
-import { createEntryFromChat } from "../lib/entries";
+import {
+  createEntryFromChat,
+  type CreateEntryFromChatArgs,
+} from "../lib/entries";
+import { buildPredictionFromNative } from "../lib/intent";
+import { composeEntryNote } from "../services/ai";
+import type {
+  EntryNotePayload,
+  IntentMetadata,
+  IntentPredictionResult,
+  ProcessingStep,
+  ProcessingStepId,
+} from "../types/intent";
+import { handleMessage } from "@/chat/handleMessage";
+import type { IntentPayload } from "@/chat/handleMessage";
+import { Memory } from "@/agent/memory";
+import type { MemoryKind } from "@/agent/memory";
+import { planAction } from "@/agent/planner";
+import type { PlannerResponse } from "@/agent/types";
+import { Telemetry } from "@/agent/telemetry";
+import { Outbox } from "@/agent/outbox";
+import { handleToolCall } from "@/agent/actions";
+import type { ToolExecutionResult } from "@/agent/actions";
 
 const successMessages: Record<EntryType, string> = {
   goal: "Saved. Keep up your hard work.",
@@ -18,7 +40,166 @@ const successMessages: Record<EntryType, string> = {
   schedule: "Saved. Your time is your power, use it wisely.",
 };
 
-export const useChatState = (onEntryCreated?: () => void) => {
+const buildLocalFallbackNote = (
+  label: string,
+  message: string
+): EntryNotePayload => ({
+  noteTitle: `${label} draft`,
+  noteBody: message.slice(0, 280).trim() || label,
+  searchTag: label.toLowerCase().replace(/\s+/g, "-") || "journal-entry",
+  guidance: "Fallback note generated locally while offline.",
+});
+
+const formatDate = (iso: string | undefined): string | null => {
+  if (!iso) return null;
+  const date = new Date(iso);
+  if (Number.isNaN(date.getTime())) return null;
+  return new Intl.DateTimeFormat(undefined, {
+    month: 'short',
+    day: 'numeric',
+  }).format(date);
+};
+
+const formatDateTime = (iso: string | undefined): string | null => {
+  if (!iso) return null;
+  const date = new Date(iso);
+  if (Number.isNaN(date.getTime())) return null;
+  return new Intl.DateTimeFormat(undefined, {
+    weekday: 'short',
+    hour: 'numeric',
+    minute: '2-digit',
+    month: 'short',
+    day: 'numeric',
+  }).format(date);
+};
+
+const buildConfirmationMessage = (
+  entryType: EntryType,
+  slots: Record<string, string>,
+  fallback: string,
+  offline: boolean
+): string => {
+  if (offline) return fallback;
+  switch (entryType) {
+    case 'schedule': {
+      const start = formatDateTime(slots.start);
+      const endTime = formatDateTime(slots.end);
+      const location = slots.location ? ` at ${slots.location}` : '';
+      if (start && endTime) {
+        return `Booked ${slots.title ?? 'your event'} → ${start} – ${endTime}${location}`;
+      }
+      if (start) {
+        return `Booked ${slots.title ?? 'your event'} → ${start}${location}`;
+      }
+      break;
+    }
+    case 'goal': {
+      const due = formatDate(slots.due);
+      if (slots.title && due) {
+        return `Locked it in: ${slots.title} • Target ${due}`;
+      }
+      if (slots.title) {
+        return `Locked it in: ${slots.title}`;
+      }
+      break;
+    }
+    case 'journal': {
+      if (slots.title) {
+        return `Captured “${slots.title}” — saved to your journal.`;
+      }
+      break;
+    }
+    default:
+      break;
+  }
+  return fallback;
+};
+
+const entryTypeToMemoryKind: Record<EntryType, MemoryKind> = {
+  journal: "entry",
+  goal: "goal",
+  schedule: "event",
+};
+
+const processingTemplate = (): ProcessingStep[] => [
+  {
+    id: "ml_detection",
+    label: "ML prediction",
+    status: "pending",
+  },
+  {
+    id: "knowledge_search",
+    label: "Knowledge base",
+    status: "pending",
+  },
+  {
+    id: "openai_request",
+    label: "OpenAI request",
+    status: "pending",
+  },
+  {
+    id: "openai_response",
+    label: "OpenAI received",
+    status: "pending",
+  },
+];
+
+const updateTimeline = (
+  timeline: ProcessingStep[],
+  stepId: ProcessingStepId,
+  status: ProcessingStep["status"],
+  detail?: string
+): ProcessingStep[] =>
+  timeline.map((step) => {
+    if (step.id !== stepId) {
+      return step;
+    }
+    const next: ProcessingStep = {
+      ...step,
+      status,
+      timestamp: new Date().toISOString(),
+    };
+    if (detail !== undefined) {
+      next.detail = detail;
+    } else {
+      delete next.detail;
+    }
+    return next;
+  });
+
+const buildIntentMeta = (
+  prediction: IntentPredictionResult
+): IntentMetadata => ({
+  id: prediction.id,
+  rawLabel: prediction.rawLabel,
+  displayLabel: prediction.label,
+  confidence: prediction.confidence,
+  subsystem: prediction.subsystem,
+  probabilities: prediction.probabilities,
+});
+
+export interface IntentReviewTicket {
+  messageId: string;
+  content: string;
+  intent: IntentPredictionResult;
+  entryType: EntryType;
+}
+
+export const useChatState = (
+  onEntryCreated?: () => void
+): {
+  messages: ChatMessage[];
+  isTyping: boolean;
+  groupMessages: (msgs: ChatMessage[]) => MessageGroup[];
+  sendMessage: (content: string) => Promise<IntentReviewTicket | null>;
+  retryMessage: (messageId: string) => Promise<void>;
+  clearMessages: () => void;
+  updateMessageIntent: (
+    messageId: string,
+    intent: IntentMetadata,
+    nextType?: EntryType
+  ) => void;
+} => {
   const [messages, setMessages] = useState<ChatMessage[]>([]);
   const [isTyping, setIsTyping] = useState(false);
   const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
@@ -40,6 +221,12 @@ export const useChatState = (onEntryCreated?: () => void) => {
           }
 
           const createdAt = entry.created_at || new Date().toISOString();
+          const baseMeta = (entry.ai_meta ?? {}) as Record<string, any>;
+          const intentMeta = baseMeta?.intent as IntentMetadata | undefined;
+          const processing = Array.isArray(baseMeta?.processingTimeline)
+            ? (baseMeta.processingTimeline as ProcessingStep[])
+            : undefined;
+
           const entryMessage: EntryMessage = {
             id: entry.id,
             kind: "entry",
@@ -52,15 +239,23 @@ export const useChatState = (onEntryCreated?: () => void) => {
               typeof entry.ai_confidence === "number"
                 ? entry.ai_confidence
                 : null,
-            aiMeta: entry.ai_meta ?? null,
+            aiMeta: baseMeta ?? null,
           };
+          if (intentMeta) {
+            entryMessage.intentMeta = intentMeta;
+          }
+          if (processing) {
+            entryMessage.processing = processing;
+          }
           chatMessages.push(entryMessage);
 
           const botMessage: BotMessage = {
             id: `bot-${entry.id}`,
             kind: "bot",
             afterId: entry.id,
-            content: successMessages[entry.type],
+            content:
+              (baseMeta?.note?.guidance as string | undefined) ??
+              successMessages[entry.type],
             created_at: createdAt,
             status: "sent",
           };
@@ -86,7 +281,6 @@ export const useChatState = (onEntryCreated?: () => void) => {
   const groupMessages = useCallback((msgs: ChatMessage[]): MessageGroup[] => {
     if (msgs.length === 0) return [];
 
-    // Sort messages by timestamp
     const sortedMsgs = [...msgs].sort(
       (a, b) =>
         new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
@@ -102,7 +296,6 @@ export const useChatState = (onEntryCreated?: () => void) => {
         currentGroup &&
         messageTime - new Date(currentGroup.timestamp).getTime() < 300000
       ) {
-        // 5 minutes
         currentGroup.messages.push(message);
       } else {
         currentGroup = {
@@ -118,109 +311,351 @@ export const useChatState = (onEntryCreated?: () => void) => {
     return groups;
   }, []);
 
-  const sendMessage = useCallback(async (content: string) => {
-    const trimmedContent = content.trim();
-    if (!trimmedContent) return;
-
-    const tempId = Date.now().toString();
-    const optimisticType: EntryType = "journal";
-    const userMessage: EntryMessage = {
-      id: tempId,
-      kind: "entry",
-      type: optimisticType,
-      content: trimmedContent,
-      created_at: new Date().toISOString(),
-      status: "sending",
-    };
+  const patchEntryMessage = useCallback(
+    (id: string, patch: (message: EntryMessage) => EntryMessage) => {
+      setMessages((prev) =>
+        prev.map((msg) =>
+          msg.id === id && msg.kind === "entry" ? patch(msg) : msg
+        )
+      );
+    },
+    []
+  );
 
-    setMessages((prevMessages) => [...prevMessages, userMessage]);
+  const sendMessage = useCallback(
+    async (content: string): Promise<IntentReviewTicket | null> => {
+      const trimmedContent = content.trim();
+      if (!trimmedContent) return null;
+
+      const tempId = Date.now().toString();
+      const createdAt = new Date().toISOString();
+      let processingTimeline = processingTemplate();
+
+      const provisional: EntryMessage = {
+        id: tempId,
+        kind: "entry",
+        type: "journal",
+        content: trimmedContent,
+        created_at: createdAt,
+        status: "sending",
+        processing: processingTimeline,
+      };
+
+      setMessages((prev) => [...prev, provisional]);
+
+      const applyProcessing = (
+        stepId: ProcessingStepId,
+        status: ProcessingStep["status"],
+        detail?: string
+      ) => {
+        processingTimeline = updateTimeline(processingTimeline, stepId, status, detail);
+        patchEntryMessage(tempId, (msg) => ({
+          ...msg,
+          processing: processingTimeline,
+        }));
+      };
+
+      let prediction: IntentPredictionResult | null = null;
+      let intentPayload: IntentPayload | null = null;
+      let notePayload: EntryNotePayload | null = null;
+      let entryType: EntryType = "journal";
+
+      try {
+        applyProcessing("ml_detection", "running", "Analyzing");
+        intentPayload = await handleMessage(trimmedContent, {
+          userTimeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
+        });
+        prediction = buildPredictionFromNative(intentPayload.nativeIntent);
+        entryType = prediction.entryType ?? "journal";
+        const intentMeta = buildIntentMeta(prediction);
+
+        applyProcessing(
+          "ml_detection",
+          "done",
+          `${prediction.rawLabel} ${(prediction.confidence * 100).toFixed(1)}%`
+        );
 
-    try {
-      const saved = await createEntryFromChat(trimmedContent);
-      const resolvedType = (saved.type ?? "journal") as EntryType;
-      const aiIntent = saved.ai_intent ?? resolvedType;
-      const aiConfidence =
-        typeof saved.ai_confidence === "number" ? saved.ai_confidence : null;
-      const aiMeta = saved.ai_meta ?? null;
+        patchEntryMessage(tempId, (msg) => {
+          const next: EntryMessage = {
+            ...msg,
+            type: entryType,
+            aiIntent: prediction?.id ?? entryType,
+            aiConfidence: prediction?.confidence ?? null,
+          };
+          if (intentMeta) {
+            next.intentMeta = intentMeta;
+          }
+          return next;
+        });
+
+        const decision = intentPayload.decision;
+        const memoryCount = intentPayload.memoryMatches.length;
+        const contextDetail =
+          memoryCount > 0
+            ? `Attached ${memoryCount} context snippet${memoryCount === 1 ? '' : 's'}`
+            : "No local context";
+
+        applyProcessing("knowledge_search", "done", contextDetail);
+
+        if (decision.kind === "fallback") {
+          applyProcessing("openai_request", "skipped", "Confidence below 45%");
+          applyProcessing("openai_response", "skipped", "Awaiting user choice");
+
+          patchEntryMessage(tempId, (msg) => ({
+            ...msg,
+            status: "sent" as const,
+            processing: processingTimeline,
+          }));
+
+          const fallbackText =
+            "Got it. How do you want me to handle that—journal it, schedule it, or set it as a goal?";
+          const botMessage: BotMessage = {
+            id: `bot-${tempId}`,
+            kind: "bot",
+            afterId: tempId,
+            content: fallbackText,
+            created_at: new Date().toISOString(),
+            status: "sent",
+          };
+
+          setMessages((prevState) => [...prevState, botMessage]);
+          return null;
+        }
+
+        if (decision.kind === "clarify") {
+          applyProcessing("openai_request", "skipped", "Awaiting clarification");
+          applyProcessing("openai_response", "skipped", "Awaiting clarification");
+
+          patchEntryMessage(tempId, (msg) => ({
+            ...msg,
+            status: "sent" as const,
+            processing: processingTimeline,
+          }));
+
+          const question = decision.question ?? "Could you clarify that intent?";
+          const botMessage: BotMessage = {
+            id: `bot-${tempId}`,
+            kind: "bot",
+            afterId: tempId,
+            content: question,
+            created_at: new Date().toISOString(),
+            status: "sent",
+          };
 
-      if (saved?.id) {
-        const entryId = saved.id;
+          setMessages((prevState) => [...prevState, botMessage]);
+          return null;
+        }
+
+        let plannerOutput: PlannerResponse | null = null;
+        let toolExecution: ToolExecutionResult | null = null;
+        let offlinePolishRequired = false;
+        try {
+          applyProcessing("openai_request", "running", "Planner routing");
+          const plannerResult = await planAction({
+            payload: intentPayload.enriched,
+          });
+          plannerOutput = plannerResult.response;
+          toolExecution = handleToolCall(plannerOutput, {
+            originalText: trimmedContent,
+          });
+          if (intentPayload.traceId) {
+            Telemetry.update(intentPayload.traceId, {
+              plan: plannerOutput ?? null,
+            }).catch((error) => {
+              console.warn('[telemetry] update failed', error);
+            });
+          }
+          applyProcessing(
+            "openai_request",
+            "done",
+            plannerOutput?.action ?? "noop"
+          );
+
+          applyProcessing("openai_response", "running", "Drafting note");
+          notePayload = await composeEntryNote({
+            userMessage: trimmedContent,
+            intent: prediction,
+            enriched: intentPayload.enriched,
+            planner: plannerOutput,
+          });
+          applyProcessing(
+            "openai_response",
+            "done",
+            notePayload.noteTitle
+          );
+        } catch (error: any) {
+          console.warn("composeEntryNote fallback", error?.message ?? error);
+          applyProcessing(
+            "openai_request",
+            "error",
+            error?.message ?? "OpenAI unavailable"
+          );
+          applyProcessing(
+            "openai_response",
+            "skipped",
+            "Fallback note"
+          );
+          const fallbackNote =
+            (error?.fallbackNote as EntryNotePayload | undefined) ??
+            buildLocalFallbackNote(prediction.label, trimmedContent);
+          notePayload = fallbackNote;
+          if (error?.offline) {
+            offlinePolishRequired = true;
+            Outbox.queue({
+              kind: "polish",
+              payload: {
+                traceId: intentPayload.traceId,
+                intent: intentPayload.routedIntent,
+                enriched: intentPayload.enriched,
+                content: trimmedContent,
+              },
+            }).catch((queueError) => {
+              console.warn("[outbox] queue failed", queueError);
+            });
+          }
+        }
+
+        if (!prediction) {
+          throw new Error("Intent prediction missing");
+        }
+
+        const confirmedPrediction = prediction;
+
+        const createArgs: CreateEntryFromChatArgs = {
+          content: trimmedContent,
+          entryType,
+          intent: confirmedPrediction,
+          note: notePayload,
+          processingTimeline,
+          nativeIntent: intentPayload?.nativeIntent,
+          enriched: intentPayload.enriched,
+          decision: intentPayload.decision,
+          redaction: intentPayload.redaction,
+          memoryMatches: intentPayload.memoryMatches,
+          plan: plannerOutput,
+        };
+
+        const saved = await createEntryFromChat(createArgs);
 
-        // Notify that an entry was created to refresh counters
         if (onEntryCreated) {
           onEntryCreated();
         }
 
-        if (timeoutRef.current) {
-          clearTimeout(timeoutRef.current);
-        }
+        const createdAtTs = saved.created_at
+          ? new Date(saved.created_at).getTime()
+          : Date.now();
+        await Memory.upsert({
+          id: saved.id,
+          kind: entryTypeToMemoryKind[entryType],
+          text: trimmedContent,
+          ts: createdAtTs,
+        });
 
-        setMessages((prevMessages) =>
-          prevMessages.map((msg) =>
-            msg.id === tempId
-              ? {
-                  ...msg,
-                  id: entryId,
-                  status: "sent" as const,
-                  type: resolvedType,
-                  aiIntent,
-                  aiConfidence,
-                  aiMeta,
-                }
-              : msg
-          )
-        );
+        const confirmedIntentMeta = buildIntentMeta(confirmedPrediction);
+        const aiMetaPayload = {
+          intent: confirmedIntentMeta,
+          routing: intentPayload.decision,
+          slots: intentPayload.routedIntent.slots,
+          memoryMatches: intentPayload.memoryMatches,
+          contextSnippets: intentPayload.enriched.contextSnippets,
+          redaction: intentPayload.redaction.replacementMap,
+          payload: intentPayload.enriched,
+          traceId: intentPayload.traceId,
+          plannedExecution: toolExecution,
+          plan: plannerOutput,
+          note: notePayload,
+          processingTimeline,
+          nativeTop3: intentPayload?.nativeIntent.top3 ?? [],
+          rawIntent: intentPayload,
+        };
 
-        appendMessage(entryId, "user", trimmedContent, {
+        patchEntryMessage(tempId, (msg) => ({
+          ...msg,
+          id: saved.id,
+          status: "sent" as const,
+          type: entryType,
+          aiIntent: confirmedPrediction.id ?? entryType,
+          aiConfidence: confirmedPrediction.confidence ?? null,
+          aiMeta: aiMetaPayload,
+          intentMeta: confirmedIntentMeta,
+          processing: processingTimeline,
+        }));
+
+        appendMessage(saved.id, "user", trimmedContent, {
           messageKind: "entry",
-          entryType: resolvedType,
-          aiIntent,
-          aiConfidence,
-          aiMeta,
+          entryType,
+          intent: aiMetaPayload.intent,
+          note: notePayload,
+          processingTimeline,
+          rawIntent: intentPayload,
         }).catch((error) => {
           console.error("Unable to record entry message", error);
         });
 
+        const baseAcknowledgement = offlinePolishRequired
+          ? "Got it. I saved that. I’ll refine wording when we’re back online."
+          : notePayload?.guidance ?? successMessages[entryType];
+        const acknowledgement = buildConfirmationMessage(
+          entryType,
+          intentPayload.routedIntent.slots,
+          baseAcknowledgement,
+          offlinePolishRequired
+        );
+
         setIsTyping(true);
 
-        const acknowledgement =
-          successMessages[resolvedType] ?? successMessages.journal;
+        if (timeoutRef.current) {
+          clearTimeout(timeoutRef.current);
+        }
 
         timeoutRef.current = setTimeout(() => {
           setIsTyping(false);
 
           const botMessage: BotMessage = {
-            id: `bot-${entryId}`,
+            id: `bot-${saved.id}`,
             kind: "bot",
-            afterId: entryId,
+            afterId: saved.id,
             content: acknowledgement,
             created_at: new Date().toISOString(),
             status: "sent",
           };
 
-          setMessages((prevMessages) => [...prevMessages, botMessage]);
+          setMessages((prevState) => [...prevState, botMessage]);
 
-          appendMessage(entryId, "assistant", acknowledgement, {
+          appendMessage(saved.id, "assistant", acknowledgement, {
             messageKind: "autoReply",
-            entryType: resolvedType,
-            afterId: entryId,
-            aiIntent,
-            aiConfidence,
-            aiMeta,
+            entryType,
+            afterId: saved.id,
+            intent: aiMetaPayload.intent,
+            note: notePayload,
+            rawIntent: intentPayload,
           }).catch((error) => {
             console.error("Unable to record auto-reply", error);
           });
         }, 1500);
+
+        return {
+          messageId: saved.id,
+          content: trimmedContent,
+          intent: confirmedPrediction,
+          entryType,
+        };
+      } catch (error) {
+        console.error("Error sending message:", error);
+        applyProcessing(
+          "openai_response",
+          "error",
+          error instanceof Error ? error.message : "Failed"
+        );
+        patchEntryMessage(tempId, (msg) => ({
+          ...msg,
+          status: "failed" as const,
+        }));
+        return null;
       }
-    } catch (error) {
-      setMessages((prevMessages) =>
-        prevMessages.map((msg) =>
-          msg.id === tempId ? { ...msg, status: "failed" as const } : msg
-        )
-      );
-      console.error("Error sending message:", error);
-    }
-  }, [onEntryCreated]);
+    },
+    [messages, onEntryCreated, patchEntryMessage]
+  );
 
   const retryMessage = useCallback(
     async (messageId: string) => {
@@ -237,10 +672,26 @@ export const useChatState = (onEntryCreated?: () => void) => {
   );
 
   const clearMessages = useCallback(() => {
-    // Only clear the visual chat messages, do NOT delete saved entries
     setMessages([]);
   }, []);
 
+  const updateMessageIntent = useCallback(
+    (messageId: string, intentMeta: IntentMetadata, nextType?: EntryType) => {
+      patchEntryMessage(messageId, (msg) => ({
+        ...msg,
+        type: nextType ?? msg.type,
+        aiIntent: intentMeta.id,
+        aiConfidence: intentMeta.confidence,
+        intentMeta,
+        aiMeta: {
+          ...(msg.aiMeta ?? {}),
+          intent: intentMeta,
+        },
+      }));
+    },
+    [patchEntryMessage]
+  );
+
   return {
     messages,
     isTyping,
@@ -248,5 +699,6 @@ export const useChatState = (onEntryCreated?: () => void) => {
     sendMessage,
     retryMessage,
     clearMessages,
+    updateMessageIntent,
   };
 };
diff --git a/src/screens/settings/PersonalizationSettingsScreen.tsx b/src/screens/settings/PersonalizationSettingsScreen.tsx
index 6151403..dafcf43 100644
--- a/src/screens/settings/PersonalizationSettingsScreen.tsx
+++ b/src/screens/settings/PersonalizationSettingsScreen.tsx
@@ -43,7 +43,7 @@ const PersonalizationSettingsScreen: React.FC<
   if (isEditing) {
     return (
       <OnboardingFlow
-        initialSettings={bundle.settings ?? undefined}
+        initialSettings={bundle.settings ?? null}
         initialTimezone={bundle.profile.timezone}
         onPersist={(state, timezone) => onSave(state, timezone)}
         onComplete={() => {
diff --git a/tsconfig.json b/tsconfig.json
index 1dbe256..0ad6946 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -4,7 +4,16 @@
     "strict": true,
     "skipLibCheck": true,
     "noEmit": true,
-    "esModuleInterop": true
+    "esModuleInterop": true,
+    "baseUrl": ".",
+    "paths": {
+      "@/*": [
+        "src/*"
+      ]
+    },
+    "noUncheckedIndexedAccess": true,
+    "exactOptionalPropertyTypes": true,
+    "noImplicitOverride": true
   },
   "exclude": [
     "supabase/functions"
--- /dev/null	2025-10-12 16:12:15
+++ src/types/react-native-safe-area-context.d.ts	2025-10-12 16:11:22
@@ -0,0 +1,22 @@
+declare module 'react-native-safe-area-context' {
+  import * as React from 'react';
+  import { ViewProps } from 'react-native';
+
+  export type Edge = 'top' | 'bottom' | 'left' | 'right';
+
+  export interface EdgeInsets {
+    top: number;
+    bottom: number;
+    left: number;
+    right: number;
+  }
+
+  export interface SafeAreaViewProps extends ViewProps {
+    edges?: Edge[];
+  }
+
+  export function useSafeAreaInsets(): EdgeInsets;
+
+  export const SafeAreaProvider: React.FC<{ children?: React.ReactNode }>;
+  export const SafeAreaView: React.ComponentType<SafeAreaViewProps>;
+}
--- /dev/null	2025-10-12 16:12:15
+++ src/types/react-native-gesture-handler.d.ts	2025-10-12 16:11:00
@@ -0,0 +1,6 @@
+declare module 'react-native-gesture-handler' {
+  import * as React from 'react';
+  import { ViewProps } from 'react-native';
+
+  export const GestureHandlerRootView: React.ComponentType<ViewProps>;
+}
