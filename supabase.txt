-- Extensions -------------------------------------------------------------
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Types -----------------------------------------------------------------
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_type
    WHERE typname = 'entry_type'
      AND typnamespace = 'public'::regnamespace
  ) THEN
    CREATE TYPE public.entry_type AS ENUM ('journal', 'goal', 'schedule');
  END IF;
END $$;

-- Tables ----------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username text,
  website text,
  avatar_url text,
  timezone text DEFAULT 'UTC',
  onboarding_completed boolean DEFAULT FALSE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  type public.entry_type NOT NULL,
  content text NOT NULL,
  metadata jsonb,
  ai_intent text,
  ai_confidence double precision,
  ai_meta jsonb,
  source text NOT NULL DEFAULT 'user',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT entries_source_check CHECK (source IN ('user', 'system', 'ai')),
  CONSTRAINT entries_ai_confidence_check CHECK (
    ai_confidence IS NULL
    OR (ai_confidence >= 0 AND ai_confidence <= 1)
  )
);

CREATE TABLE IF NOT EXISTS public.messages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id uuid NOT NULL REFERENCES public.entries(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL CHECK (role IN ('system', 'user', 'assistant')),
  content text NOT NULL,
  metadata jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.user_settings (
  user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  personalization_mode text NOT NULL CHECK (personalization_mode IN ('basic', 'full')) DEFAULT 'full',
  local_cache_enabled boolean NOT NULL DEFAULT TRUE,
  cadence text NOT NULL CHECK (cadence IN ('none', 'daily', 'weekly')) DEFAULT 'none',
  goals text[] NOT NULL DEFAULT ARRAY[]::text[],
  extra_goal text,
  learning_style jsonb NOT NULL DEFAULT jsonb_build_object('visual', 5, 'auditory', 5, 'kinesthetic', 5),
  session_length_minutes integer NOT NULL DEFAULT 25,
  spiritual_prompts boolean NOT NULL DEFAULT FALSE,
  bluntness integer NOT NULL DEFAULT 5,
  language_intensity text NOT NULL CHECK (language_intensity IN ('soft', 'neutral', 'direct')) DEFAULT 'neutral',
  logging_format text NOT NULL CHECK (logging_format IN ('freeform', 'structured', 'mixed')) DEFAULT 'mixed',
  drift_rule jsonb NOT NULL DEFAULT jsonb_build_object('enabled', FALSE, 'after', NULL),
  crisis_card text,
  persona_tag text NOT NULL DEFAULT 'Generalist',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.persona_signals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  source text NOT NULL CHECK (source IN ('onboarding', 'settings_update')),
  rationale text NOT NULL,
  payload jsonb NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes ---------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_entries_user_id ON public.entries(user_id);
CREATE INDEX IF NOT EXISTS idx_entries_created_at ON public.entries(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_entries_type ON public.entries(type);

CREATE INDEX IF NOT EXISTS idx_messages_user_id ON public.messages(user_id);
CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON public.messages(conversation_id);
CREATE INDEX IF NOT EXISTS idx_messages_created_at ON public.messages(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_persona_signals_user ON public.persona_signals(user_id, created_at DESC);

-- Triggers & Functions --------------------------------------------------
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS set_profiles_updated_at ON public.profiles;
DROP TRIGGER IF EXISTS profiles_set_updated_at ON public.profiles;
CREATE TRIGGER profiles_set_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS set_entries_updated_at ON public.entries;
DROP TRIGGER IF EXISTS entries_set_updated_at ON public.entries;
CREATE TRIGGER entries_set_updated_at
  BEFORE UPDATE ON public.entries
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS set_messages_updated_at ON public.messages;
DROP TRIGGER IF EXISTS messages_set_updated_at ON public.messages;
CREATE TRIGGER messages_set_updated_at
  BEFORE UPDATE ON public.messages
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS user_settings_set_updated_at ON public.user_settings;
CREATE TRIGGER user_settings_set_updated_at
  BEFORE UPDATE ON public.user_settings
  FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- Row Level Security ----------------------------------------------------
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.persona_signals ENABLE ROW LEVEL SECURITY;

-- Policies --------------------------------------------------------------
DROP POLICY IF EXISTS profiles_select_own ON public.profiles;
CREATE POLICY profiles_select_own ON public.profiles
  FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS profiles_insert_own ON public.profiles;
CREATE POLICY profiles_insert_own ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS profiles_update_own ON public.profiles;
CREATE POLICY profiles_update_own ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

DROP POLICY IF EXISTS profiles_delete_own ON public.profiles;
CREATE POLICY profiles_delete_own ON public.profiles
  FOR DELETE USING (auth.uid() = id);

DROP POLICY IF EXISTS entries_select_own ON public.entries;
CREATE POLICY entries_select_own ON public.entries
  FOR SELECT USING (user_id = auth.uid());

DROP POLICY IF EXISTS entries_insert_own ON public.entries;
CREATE POLICY entries_insert_own ON public.entries
  FOR INSERT WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS entries_update_own ON public.entries;
CREATE POLICY entries_update_own ON public.entries
  FOR UPDATE USING (user_id = auth.uid());

DROP POLICY IF EXISTS entries_delete_own ON public.entries;
CREATE POLICY entries_delete_own ON public.entries
  FOR DELETE USING (user_id = auth.uid());

DROP POLICY IF EXISTS messages_select_own ON public.messages;
CREATE POLICY messages_select_own ON public.messages
  FOR SELECT USING (user_id = auth.uid());

DROP POLICY IF EXISTS messages_insert_own ON public.messages;
CREATE POLICY messages_insert_own ON public.messages
  FOR INSERT WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS messages_update_own ON public.messages;
CREATE POLICY messages_update_own ON public.messages
  FOR UPDATE USING (user_id = auth.uid());

DROP POLICY IF EXISTS messages_delete_own ON public.messages;
CREATE POLICY messages_delete_own ON public.messages
  FOR DELETE USING (user_id = auth.uid());

DROP POLICY IF EXISTS user_settings_select_own ON public.user_settings;
CREATE POLICY user_settings_select_own ON public.user_settings
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS user_settings_upsert_own ON public.user_settings;
CREATE POLICY user_settings_upsert_own ON public.user_settings
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS persona_signals_select_own ON public.persona_signals;
CREATE POLICY persona_signals_select_own ON public.persona_signals
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS persona_signals_insert_own ON public.persona_signals;
CREATE POLICY persona_signals_insert_own ON public.persona_signals
  FOR INSERT WITH CHECK (auth.uid() = user_id);

NOTIFY pgrst, 'reload schema';
